<html>

<head>
  <title>Blueprint Drawing thingy</title>
  <style>
    canvas {
      border: 1px solid black;
    }

    .canvas-container {
      position: relative;
      width: 100%;
      padding-bottom: 56.25%;
      /* Set the aspect ratio to 16:9 */
    }

    .canvas-container canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
  </style>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/Base64/1.2.0/base64.min.js"
    integrity="sha512-wuN7AU4m/qE3ZCKOCoBIuTU4M/dK8w8becOGgb4geNwPDm69wwu1AqZut6awol/qllGfyySmSoQ2CRwJADXKOA=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>
  <script src="https://cdnjs.cloudflare.com/ajax/libs/pako/2.1.0/pako.min.js"
    integrity="sha512-g2TeAWw5GPnX7z0Kn8nFbYfeHcvAu/tx6d6mrLe/90mkCxO+RcptyYpksUz35EO337F83bZwcmUyHiHamspkfg=="
    crossorigin="anonymous" referrerpolicy="no-referrer"></script>

  <script>
    window.addEventListener('DOMContentLoaded', () => {
      const queryString = window.location.search;
      const urlParams = new URLSearchParams(queryString);
      const bpValue = urlParams.get('bp');
      const blueprintTextbox = document.getElementById('blueprint-textbox');
      blueprintTextbox.value = bpValue;
    });
  </script>


</head>

<body>
  <form action="" method="get">
    <label for="blueprint-textbox">Blueprint:</label><br>
    <textarea id="blueprint-textbox" rows="10" cols="50" name="bp"></textarea><br>
    <button id="draw-button" type="submit">Draw Blueprint</button>
  </form>
  <br>
  <div>
    <p>Stability. Cost:<span id="stability-cost"></span>, Conferred: <span id="stability-conferred"></span></p>
    <p>Power Consumption. Idle: <span id="power-consumption-idle"></span>, Max:<span id="power-consumption-max"></span>, Produced:<span id="power-produced"></span></p>
    <p>Heat Rate: <span id="heat-rate"></span></p>
  </div>
  <div class="canvas-container">
    <canvas id="myCanvas" width="500" height="500"></canvas>
  </div>


  <script>


    function decode(bps) {
      bps = bps.substring(16);
      var bpsb = atob(bps);
      var bytes = new Uint8Array(bpsb.length);
      for (var i = 0; i < bpsb.length; i++) {
        bytes[i] = bpsb.charCodeAt(i);
      }
      var inflated = pako.inflate(bytes, {
        to: 'string'
      });
      return JSON.parse(inflated);
    }

    function get_rotated_object_info(obj) {
      // Get position and rotation values
      const pos = obj['OriginalPlacedPosition'];
      const rot = obj['OriginalRotation']['value'];

      // Calculate width and height after rotation
      const length = obj['Length'];
      const width = obj['Width'];
      const yaw = Math.atan2(2 * (rot['w'] * rot['z'] + rot['x'] * rot['y']), 1 - 2 * (rot['y'] ** 2 + rot['z'] ** 2));
      const wcos = Math.abs(rot['w'] * Math.cos(yaw) - rot['z'] * Math.sin(yaw));
      const wsin = Math.abs(rot['w'] * Math.sin(yaw) + rot['z'] * Math.cos(yaw));
      const hcos = Math.abs(rot['w'] * Math.cos(yaw) - rot['x'] * Math.sin(yaw));
      const hsin = Math.abs(rot['w'] * Math.sin(yaw) + rot['x'] * Math.cos(yaw));
      const width_rotated = length;
      const height_rotated = width;

      // Calculate center_x and center_y
      const center_x = pos['z'] / 10;
      const center_y = pos['x'] / 10;

      // Return values as an object
      return {
        center_x,
        center_y,
        width: width_rotated,
        height: height_rotated,
        itemName: obj['ItemName']
      };
    }

    function drawBox(ctx, box, minX, minY, scalingFactor) {

      // Scale and shift the box coordinates
      const center_x = (box.center_x - minX) * scalingFactor;
      const center_y = (box.center_y - minY) * scalingFactor;

      let width = box.width * scalingFactor;
      let height = box.height * scalingFactor;
      // Normalize coordinates to fit in canvas
      let x = center_x - width / 2;
      let y = center_y - height / 2;
      drawRect(ctx, x, y, width, height);
      addImage(ctx, box, x, y, width, height);
    }

    function drawRect(ctx, x, y, width, height) {
      ctx.fillStyle = "black";
      ctx.fillRect(x, y, width, height);
      ctx.strokeStyle = "red";
      ctx.lineWidth = 4;
      ctx.strokeRect(x, y, width, height);
    }

    // Add image
    function addImage(ctx, box, x, y, width, height) {

      const img = new Image();
      img.src = `Icons/${box.itemName.replace(/\s/g, '')}.png`;
      img.onload = () => {
        const imgAspect = img.width / img.height;
        const boxAspect = width / height;
        let imgWidth = width;
        let imgHeight = height;
        if (imgAspect > boxAspect) {
          imgWidth = Math.min(width, img.width);
          imgHeight = imgWidth / imgAspect;
        } else {
          imgHeight = Math.min(height, img.height);
          imgWidth = imgHeight * imgAspect;
        }
        const imgX = x + (width - imgWidth) / 2;
        const imgY = y + (height - imgHeight) / 2;
        ctx.drawImage(img, imgX, imgY, imgWidth, imgHeight);
        drawLabel(ctx, box.itemName, x, y, width, height);
      };
    }

    // Draw label
    function drawLabel(ctx, label, x, y, width, height) {
      const labelY = y + 48;
      ctx.fillStyle = "white";
      ctx.font = "48px Arial";
      const words = label.split(' ');
      let line = '';
      let lines = [];
      for (let i = 0; i < words.length; i++) {
        const testLine = line + words[i] + ' ';
        const testWidth = ctx.measureText(testLine).width;
        if (testWidth > width - 20) {
          lines.push(line.trim());
          line = words[i] + ' ';
        } else {
          line = testLine;
        }
      }
      lines.push(line.trim());
      for (let i = 0; i < lines.length; i++) {
        const labelWidth = ctx.measureText(lines[i]).width;
        ctx.fillText(lines[i], x + width / 2 - labelWidth / 2, labelY + i * 48);
      }
    }

    function drawBoxes(canvas, boxList, document) {

      let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
      const padding = 10;
      const minBoxSize = 50;
      const aspectRatio = 16 / 9; // Set the aspect ratio of the canvas
      const windowWidth = window.innerWidth;
      const windowHeight = window.innerHeight;
      const canvasWidth = windowWidth - padding * 2;
      const canvasHeight = windowHeight - padding * 2;
      const canvasAspectRatio = canvasWidth / canvasHeight;
      const scalingFactor = canvasAspectRatio > aspectRatio
        ? canvasHeight / (Math.max(...boxList.map(b => b.height)) * 1.1)
        : canvasWidth / (Math.max(...boxList.map(b => b.width)) * 1.1);

      // Loop through the boxes to find the min and max coordinates
      boxList.forEach(box => {
        minX = Math.min(minX, box.center_x - box.width / 2);
        minY = Math.min(minY, box.center_y - box.height / 2);
        maxX = Math.max(maxX, box.center_x + box.width / 2);
        maxY = Math.max(maxY, box.center_y + box.height / 2);
      });

      // Calculate the size of the canvas based on the size of the boxes
      const width = (maxX - minX) * scalingFactor;
      const height = (maxY - minY) * scalingFactor;
      canvas.width = width;
      canvas.height = height;

      // Draw boxes and images
      const ctx = canvas.getContext("2d");
      const boxSize = 50;
      for (let box of boxList) {
        // Load and draw image
        drawBox(ctx, box, minX, minY, scalingFactor);
      }
    }

    const canvas = document.getElementById('myCanvas');
    const stabilityCostElement = document.getElementById("stability-cost");
    const stabilityconferredElement = document.getElementById("stability-conferred");
    const powerConsumptionIdleElement = document.getElementById("power-consumption-idle");
    const powerConsumptionMaxElement = document.getElementById("power-consumption-max");
    const powerProducedElement = document.getElementById("power-produced");
    const heatRateElement = document.getElementById("heat-rate");

    const queryParams = new URLSearchParams(window.location.search);
    const bps = queryParams.get('bp');
    console.log(bps)
    const d = decode(bps);
    const image_locs = d["Items"].map(item => get_rotated_object_info(item));


    const itemDataUrl = "itemData.json";
    let itemLookup = {};
    fetch(itemDataUrl)
      .then(response => response.json())
      .then(jsonData => {
        jsonData.items.forEach(item => {
          itemLookup[item.name] = item;
        });

        let totalStabilityCost = 0, totalPowerIdle = 0, totalPowerMax = 0, totalPowerProduced = 0, totalHeatRate = 0, totalStabilityConferred = 0;
        image_locs.forEach(box => {
          console.log(box.itemName);
          let itemInfo = itemLookup[box.itemName];
          if (!itemInfo) {
            console.log("ERROR: No item info for " + box.itemName);
          }
          else {
            totalStabilityCost += itemInfo.stabilityCost;
            totalStabilityConferred += itemInfo.stabilityConferred;
            totalPowerIdle += itemInfo.powerConsumptionIdle;
            totalPowerMax += itemInfo.powerConsumptionMax;
            totalPowerProduced += itemInfo.powerProduction;
            totalHeatRate += itemInfo.heatRate;

          }
        });
        // Set the innerText values
        stabilityCostElement.innerText = totalStabilityCost;
        stabilityconferredElement.innerText = totalStabilityConferred;
        powerConsumptionIdleElement.innerText = totalPowerIdle;
        powerConsumptionMaxElement.innerText = totalPowerMax;
        powerProducedElement.innerText = totalPowerProduced;
        heatRateElement.innerText = totalHeatRate;

      })
      .catch(error => console.error(error));


    drawBoxes(canvas, image_locs);

    // drawButton.addEventListener('click', function() {
    //     const bps = blueprintTextbox.value;
    //     const d = decode(bps);
    //     const image_locs = d["Items"].map(item => get_rotated_object_info(item));
    //     drawBoxes(canvas, image_locs);
    //   });



    console.log(image_locs)


  </script>

</body>

</html>